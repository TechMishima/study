# ToDo
基礎理論の動画学習<br>
「過去問を解きまくる。練習が必要な知識が多いため」<br>
学習して練習できそうなら進めていく。<br>
https://www.youtube.com/@kihonzyouhou/playlists

# TIL

出題率が高いので頑張って学習する。

## 1.ｎ進数の概念

コンピュータは2進数で計算されている。

「0と1」のどちらかが入る箱を ビット（bit）という。<br>
ビットが8個集まったものを バイト（Byte）という。

### 文字の表現

文字コード : 文字のそれぞれに0と1で表現される識別番号が割り振られている

- シフトJISコード
  - あ : 1000 0010 1010 0000
- Unicode
  - あ : 1110 0011 1000 0001 1000 0010

文字化け : 作成者が使用したコードと異なる文字コードを当てはめると文字が表示されない

### ｎ進数とは

ｎ種類の記号を用いて数を表現すること

- 10進数
- 2進数
  - コンピュータの処理
- 16進数
  - 0-9とA-Fの16個の記号で数を表現

n個集まると繰り上がる<br>
繰り上がりを活用して数値を表現している

### 17を16進数、2進数で表記してみよう

16進数）

17は16と1に分けられる。<br>
16で繰り上がるので<br>
「11₁₆」となる。<br>
右下に16数であることを表記しておく。

2進数）

2、4、8、16の時に繰り上がる。<br>
16と1に分けられるので<br>
「10001₂」となる。<br>
こちらも右下に2進数であることを表記しておく。

10進数）

17₁₀と右下に表記しておく。

### 基数と重み

10進数は桁が上がると10倍増えていく。<br>
2進数は桁が上がると2倍増えていく。<br>
増えていく大きさを「重み」と呼ぶ。

また、10倍の10や2倍の2を「基数」と呼ぶ。

>n進数の基数重みの公式<br>
<br>
基数 : n<br>
整数部の重み : n⁰,n¹,n²・・・・<br>
小数部の重み : n⁻¹,n⁻²・・・・

## 2.基数変換

基数変換 : ｎ進数のｎを他の数字に変換して表現すること<br>
良く出題される分野

### 基数変換の概略

- 私たちの世界
  - 10進数
- コンピュータの世界
  - 2進数
  - 8進数
  - 16進数

コンピュータは2進数を使用するが、桁が増えて数値がわかりにくい<br>
8進数と16進数は2進数と簡単に変換できるため、使われる場面が多い。

<font color="yellow">
2/8/10/16進数の4つを自由に変換できるようになればOK
</font>

<b>問題の種類</b>
- ｎ進数から10進数
- 10進数からｎ進数

### ｎ進数から10進数への変換

<font color="yellow">
各桁の重みと数値をかけ算して結果を合計する
</font>

例）8進数137.4を10進数へ変換

各桁の重みは<br>
8²、8¹、8⁰、8⁻¹なので<br>
64、8、1、0.125になる。

各桁の重みと数値を掛け算して<br>
64*1=64<br>
8*3=24<br>
1*7=7<br>
0.125*4=0.5

結果を合計して<br>
64+24+7+0.5 = 95.5

### 10進数からｎ進数への変換

計算方法は2種類ある
- 重みを使う
- 掛け算/割り算で計算

### 10進数からｎ進数への変換(重みver)

<font color="red">
数値が複雑だと計算が大変
</font>

重みで引き算できる場合、引き算して取っておく

例）10進数38.625を2進数に変換

38.625 - 32 = 6.625<br>
6.625 - 4 = 2.625<br>
2.625 - 2 = 0.625<br>
0.625 - 0.5 = 0.125<br>
0.125 - 0.125 = 0

よって100110.101

### 10進数からｎ進数への変換(かけわりver)

<font color="yellow">
実際に使うのはこちらなので、腹落ちできるまで復習する！
</font>

例）10進数38.625を2進数に変換

①整数部を2で割り算していき、商が0になるまで繰り返す
```
38 / 2 = 19 あまり 0
19 / 2 = 9 あまり 1
9 / 2 = 4 あまり 1
4 / 2 = 2 あまり 0
2 / 2 = 1 あまり 0
1 / 2 = 0 あまり 1
```

②小数部を2で掛け算していき、積が1.0になるまで繰り返す
```
0.625 * 2 = 1.25
0.25 * 2 = 0.5
0.5 * 2 = 1.0
```

③整数部は余りを下から上に、小数部は積の整数部を上から下に書き留めていく
```
整数部は下から
100110
小数部は上から
101
よって
100110.101
```

<font color="yellow">
8進数/16進数も同様の方法で変換できるが、<br>
2進数に変換してから8/16進数に変換したほうが容易でミスも少なくなる！
</font>

### 2進数から8,16進数への変換

例）2進数1101011.01を8進数に変換

小数点をベースに2進数を3桁区切りに分け、各ブロックを8進数に直す
```
001 101 011 . 010
 1   5   3  .  2

= 153.2(8進数)
```

例）8進数63.5を2進数に変換

8進数の各桁を2進数3桁で表現してくっつける
```
6 = 110
3 = 011
5 = 101

110011.101(2進数)
```

<font color="yellow">
16進数の場合は4桁区切りで変換していけばOK
</font>

### 基数変換まとめ

<font color="yellow">
①ｎ進数から10進数への変換
</font>

各桁の重みと数値を掛け算

<font color="yellow">
②10進数から2進数への変換
</font>

割り算と掛け算で計算

<font color="yellow">
③2進数と8/16進数の相互変換
</font>

3桁区切り、4桁区切りで考える

## 3.2進数の足し算・引き算

### 2進数の足し算

<font color="yellow">
足して2になったら繰り上がる
</font>

例）
```
  10100011
 +10010111

=100111010
```

### 引き算の注意点

コンピューターは足し算しかできない<br>
負の数を表現して、引き算を足し算のように実行しなくてはならない<br>
負の数の表現として「符号ビット」と「補数表現」がある

### 符号ビット

一番最初のビットを符号として扱う（符号付2進数）
（0：正 1：負）

例）
```
1001(符号付2進数)

1はマイナス、001は3なので
-3（10進数表現）
```

<font color="red">
この表現方法だと引き算ができない
</font>

### 補数表現

n進数では次の２つの補数を考える
- nの補数 : 桁上がりするのに必要な最小の数
- (n-1)の補数 : 現在の桁のまま最大の数になるために必要な数

例）10進数450の場合
```
450の「10の補数」
450 + 550 = 1,000(桁が4桁に上がる)
よって550

450の「9の補数」
450 + 549 = 999(3桁の中の最大値になる)
よって549
```

### なぜ補数で引き算ができるのか

例）10進数の引き算 673-450
```
673 - 450 = 223

450の補数を足し算する
673 + 550 = 1223

次の桁の1000を無視すれば223になる
673 + (1000-450)
673 - 450 +(1000)
```

よって補数を活用すれば足し算で引き算を行うことができる

### 2進数の補数表現

<font color="yellow">
2進数の補数は簡単につくれる！<br>
①ビットを反転(0と1を入れ替える)<br>
②1をプラスする
</font>

例）2進数1100101
```
2進数 : 1100101

ビットを反転する
1の補数 : 0011010

1をプラスする
2の補数 : 0011011
```

<font color="yellow">
同様の処理を行うと補数が元の数に戻る
</font>

### 2進数の引き算の手順

①先頭ビットが符号ビット<br>
②8ビットの2進数

例）01001100(10進数で76) - 00001001(10進数で9)
```
2の補数を求める
00001001
ビット反転して
11110110
1をプラスして
11110111

足し合わせる
 01001100
+11110111

=101000011
先頭の1をけして
01000011 (10進数の67)
```

<font color="red">
「負の数は2の補数で表現する」と記載がある場合、<br>
先頭ビットを符号として2の補数で負の数を表現
</font>

### 8ビット2進数が表せる数値の範囲

- 符号無2進数 : 0～255
- 符号付2進数 : -128～127

|2進数|符号無2進数|符号付2進数|
|---|---|---|
|00000000|0|0|
| ・・・ | ・・・ | ・・・ |
| 01111111 | 127 | 127 |
| 10000000 | 128 | -128 |
| 10000001 | 129 | -127 |
| ・・・ | ・・・ | ・・・ |
| 11111111 | 255 | -1 |

## 4. シフト演算

### シフト演算とは

2進数を表すビット列を左右にずらすこと

<b>10進数の場合</b><br>
73.6を左に1つずらすと736になる。（10倍している）<br>
73.6を右に1つずらすと7.36になる。（1/10倍している）<br>
よって、桁がずれると10倍「基数倍」ずれていることがわかる

2進数の場合も同じ<br>
左にｎ個ずれると「2のｎ乗倍」<br>
右にｎ個ずれると「2の-ｎ乗倍」

桁をずらすには「論理シフト」と「算術シフト」がある

### 論理シフト(左シフト)

符号を考慮せずにシフト操作する掛け算

例）00101010を2ビット左シフトする
```
00101010 (10進数 : 42)
↓
10101000 (10進数 : 168)
左にシフトし、はみ出たスペースは無視し、空いたスペースは0で埋める
```

<font color="red">
そのビット数で表現できる値を超えたことを意味するオーバーフローが発生することがある<br>
論理シフトでは1がはみ出たときにオーバーフローと判断する
</font>

例）00101010を3ビット左シフトする
```
00101010 (10進数 : 42)
↓
01010000 (10進数 : 80？)
先頭にあった1がはみ出て無視されてしまったから
```

### 論理シフト(右シフト)

符号を考慮せずにシフト操作する割り算

例）01001000を2ビット右シフトする
```
01001000 (10進数 : 72)
↓
00010010 (10進数 : 18)
右にシフトし、はみ出たスペースは無視し、空いたスペースは0で埋める
```

<font color="cyan">
はみ出した部分は割り算の余りを表している
</font>

例）01001001を2ビット左シフトする
```
01001001 (10進数 : 73)
↓
00010010 (10進数 : 18 あまり1)
末尾のはみだした部分は余り
```

### 算術シフト（左シフト）

符号を考慮してシフト操作する（掛け算）

例）11101000を左に2ビット左シフトする
```
11101000 (10進数 : -24)
↓
10100000 (10進数 : -96)
符号以外を2ビット左に移動させる
空いたところを0で埋める
```

<font color="yellow">
算術シフトの場合は符号ビットと異なる値がはみ出したらオーバーフロー
</font>
<br>
上記だと符号ビットが1なので0がはみ出るとオーバーフロー

### 算術シフト（左シフト）

符号を考慮してシフト操作する（割り算）

<font color="yellow">
算術シフトの場合は空いたスペースに「符号ビット」を埋める
</font>

例）11101000を右に2ビット右シフトする
```
1 1101000 (10進数 : -24)
↓
1 □□11010××
空いたところに符号ビット、はみ出したところは無視
1 1111010 (10進数 : -6)
```
<font color="cyan">
はみ出した部分は割り算の余りを表しているのは算術シフトも同じ
</font>

### シフト演算まとめ

||論理シフト(考慮なし)|算術シフト(符号考慮)|
|---|---|---|
| 左シフト(掛け算)|・空いたスペースに0を入れる<br>・1がはみ出るとオーバーフロー|・空いたスペースに0を入れる<br>・符号ビットと異なる数字がはみ出るとオーバーフロー|
| 右シフト(割り算) |・空いたスペースに0を入れる<br>・はみ出た分は割り算の余り|・空いたスペースに符号ビットを入れる<br>・はみ出た分は割り算の余り|

### （参考）２のｎ乗以外の掛け算割り算

<font color="cyan">
分配法則で解くことはできる
</font>

例）1100100を7で掛け算
```
7 = 4 + 2 + 1
  = 2^2 + 2^1 + 2^0

  1100100 × 7 
= 1100100 × (2^2 + 2^1 +2^0)
ここで1100100をｚとおいてみると
= ｚ×2^2 + ｚ×2^1 + ｚ×2^0
元の値に「2ビット左シフトした値」と「1ビット左シフトした値」を足し合わせれば求められる！
```