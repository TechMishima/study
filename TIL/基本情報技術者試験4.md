# ToDo
ハードウェアの動画学習<br>
「重要なポイントを中心に、インプットをしっかりと行う」<br>
https://www.youtube.com/@kihonzyouhou/playlists

# TIL ハードウェア

ハードウェアという分野の全体の中でどこを学習しているのかを意識をする！

## 1.五大装置とノイマン型コンピューター

### コンピューターの構成要素

- ハードウェア
  - キーボードやマウスなど直接触れることが出来るもの
- ソフトウェア
  - ExcelやPowerPointなど直接触れることができないもの

### 五大装置＿制御装置と演算装置

- 制御装置 : 命令を解釈してコンピューターの動作を制御
- 演算装置 : データの計算や演算処理を実行

上記の二つを合わせて「CPU」と呼ぶ。<br>
コンピューターの脳みそ

<font color="yellow">
テスト出題内容<br>
- どのように命令を実行してパソコンを制御するか<br>
- CPUの性能はどうやって評価するか<br>
- どうすればCPUの性能を上げることができるか
</font>

### 五大装置＿記憶装置

- 記憶装置
  - 主記憶装置 : データを一時的に保存する装置
    - 容量が小さい・読み書きが早い
  - 補助記憶装置 : データを長期間保存する装置
    - 容量が大きい・読み書きが遅い

<font color="yellow">
テスト出題内容<br>
- メモリの分類・高速化手法<br>
- HDDに関する問題
</font>

### 五大装置＿入力装置と出力装置

- 入力装置 : データを入力する機械
  - マウスやキーボードなど
- 出力装置 : データを出力する機械
  - モニターやプリンターなど

<font color="yellow">
試験の出題頻度は高くはないので、代表的な装置や出題される分野に絞る
</font>

### 五大装置のデータ・制御の流れ

制御の流れは「制御装置」から各装置へ<br>
データの流れは「入力装置」から「記憶装置」を経由して各装置へ

### ノイマン型コンピューター

ほとんどがノイマン型。非ノイマン型として量子コンピューターがある。<br>
ノイマン型は2つの特徴がある。

<b>①プログラム内蔵方式</b>

プログラムを実行するタイミングでデータを主記憶装置に読み込ませる。<br>
Excelなどのアプリケーションプログラムを保存しておくのは補助記憶装置。実行するときに主記憶装置が読み込んで実行する。

<b>②逐次制御方式</b>

命令を前から一つずつ取り出し、順番に実行していく

## 2.CPUと命令実行手順

### プログラム内蔵方式の復習

命令実行時に「補助記憶装置」から「主記憶装置」へプログラム(命令)を移す。<br>
「主記憶装置」のプログラムを「CPU」が読み込む。

### メモリの構成

記憶装置の「メモリ」には命令内容や必要なデータが入っている領域がたくさんある。<br>
領域ごとに割り振った数字があり、「アドレス」もしくは「番地」と呼ぶ。

### レジスタ

レジスタ : 命令やデータを一時的に保存するCPU内部の記憶装置

超高速で処理できるが超小容量(32-64ビット)

レジスタの種類
| 名称 | 役割 |
| :-- | --: |
| プログラムカウンタ<br>(プログラムレジスタ) | 次に実行する命令のアドレスを記憶 |
| 命令レジスタ | 実行する命令を一時的に記憶 |
| インデックスレジスタ | 基準アドレスを記憶（インデックスアドレス指定方式で使用） |
| ベースレジスタ | 基準アドレスを記憶（ベースアドレス指定方式で使用） |
| アキュムレーター | 演算対象や演算結果を記憶 |
| 汎用レジスタ | 用途を限定せず、各主目的で使用 |

<font color="yellow">
プログラムカウンタ、命令レジスタ、汎用レジスタは出題される可能性あり
</font>

### 制御装置の構成

- プログラムカウンタ
  - 次に実行する命令のメモリのアドレス
- 命令レジスタ
  - 命令部 : 取り出した命令を一時的に格納
    - 命令を格納
  - オペランド部
    - 対象データがどこにあるか格納(アドレス指定方式)
- デコーダー（命令解読器）
  - 命令を解読して必要な装置に指示を出す

### 演算装置の構成

- 演算装置(ALU)
  - 演算を行う装置
- 汎用レジスタ
  - 演算結果を一時的に保存するなど様々な用途で使用

### 命令の実行手順

- 命令取り出し(フェッチ)
- 命令の解読
- オペランド読み出し
- 命令実行

<b>命令取り出し</b>

制御装置の「プログラムレジスタ」に格納されている番号を参照して、<br>
記憶装置の「メモリ」に格納されている命令を取り出す。<br>
取り出した命令は制御装置の「命令レジスタ」に命令部とオペランド部に格納される。<br>
この処理を行ったあと、プログラムレジスタは次の命令を出すために変わる。

<b>命令の解読</b>

「命令部」に入っているデータを「デコーダー(命令解読器)」に送り、各装置へ信号を送る。

<b>オペランド読み出し</b>

制御装置の「オペランド部」に入っている数値を参照し、<br>
記憶装置の「メモリ」に格納されているデータを、<br>
演算装置の「汎用レジスタ」へ送る。

<b>命令実行</b>

命令を実行する。<br>
もし、演算であれば「汎用レジスタ」のデータを、<br>
演算装置の「演算装置(ALU)」に送り、計算を行い、<br>
その計算結果を「汎用レジスタ」に格納する。

## 3.アドレス指定方法

オペランド部 : 命令を実施するためのデータ番地などが入る。<br>
・データそのものを保持<br>
・データが格納されてるアドレスを保持<br>
などが入っている。

格納されたデータをどう扱うかは「アドレス指定方法」によって異なる。

<font color="red">
複雑な内容なので完全理解は難しい。後々の分野にそこまで影響が無いため、概略だけは掴む
</font>

### 即値アドレス指定方法

- オペランド部の値をデータとして使用

### 直接アドレス指定方法

- オペランド部に入ってる値のメモリアドレスに入ってるデータを使用

命令を変えず、メモリに入っているデータを変えるだけで修正できる

### 間接アドレス指定方法

- オペランド部に入ってる値のメモリアドレスに入っている値のメモリアドレスに入ってるデータを使用

直接とは違い、メモリに入っているアドレスを使用する。<br>
命令を変えずにメモリを変えることで対応することができ、柔軟な修正ができるのがメリット。

### インデックスアドレス指定方式

- オペランド部にインデックスレジスタの値を加算した値のアドレスに入ってるデータを使用

オペランド部が100、インデックスレジスタが450の場合、メモリの550のデータを使用する。<br>
連続したアドレスを扱うときに使用する。

### ベースアドレス指定方式

- オペランド部にベースレジスタの値を加算した値のアドレスに入ってるデータを使用

オペランド部が100、ベースレジスタが450の場合、メモリの550のデータを使用する。<br>
インデックスアドレスとの違いとして、ベースレジスタはプログラムがメモリに移された際の先頭アドレスを記憶していること。<br>
例）
```
1.メモリのデータが100、オペランド部 100

データが100あるので命令が入ってくるのは101～になる
よってベースレジスタ : 101
オペランド部の100と足して201番目のデータを取り出すことになる。

2.メモリのデータが500、オペランド部 100

長く使っているとデータの追加があり、大きくなる。
データが500あるので命令が入ってくるのは501～になる
よってベースレジスタ : 501
オペランド部の100と足して601番目のデータを取り出すことになる。
```

<font color="cyan">
他のメモリで実行する際に命令を変えなくて済む
</font>

### 相対アドレス指定方式

- オペランド部にプログラムカウンタの値を加算した値のアドレスに入ってるデータを使用

ベースレジスタを持たないCPUで使われる。<br>
プログラムカウンタは次に実行されるアドレスを保持しているので、<br>
ベースレジスタ指定方式と同様に相対的な位置関係を保つことが可能

## 4.CPUの性能指標

<font color="magenta">
テスト頻出の計算問題なので必ず理解する！
</font>

### クロック周波数

CPUなどは、足並みをそろえて動く。

電圧のONとOFFによって、CPUは動いたり動かなかったりしている。<br>
このONとOFFの1周期を「クロック」と呼び、電圧の事を「クロック信号」と呼ぶ。<br>
1秒間あたりのクロック数は「クロック周波数」と呼ぶ。<br>
クロック周波数が大きいほど、ＣＰＵの性能は高い。

### CPI

Clock cycles Per Instruction<br>
1命令当たり何クロック必要かを表している。<br>
少ないクロックで多くの命令をこなしたいので、小さいほど性能は良い。

例）1命令当たり2クロック必要 : 2CPI

### MIPS

<font color="magenta">
頻出の計算問題！
</font>

Million Instructions Per Second<br>
1秒間で実行できる命令の数(百万単位)<br>
クロック周波数とCPIがあれば求められる。

### 命令ミックス

命令の種類によって必要なクロック数（CPI）が異なる<br>
出現頻度で重みづけしたクロック数を用いてMIPSを算出すべき<br>
上記の「出現頻度で重みづけ」の考え方を「命令ミックス」と呼ぶ。

例）
```
命令A : 必要クロック数10、出現頻度50％
命令B : 必要クロック数16、出現頻度25％
命令C : 必要クロック数8、出現頻度25％

平均クロック数 : 5+4+2 = 11クロック
```

## 5.CPUの高速化

### 逐次制御方式

CPUが1命令ずつ処理を行うため、命令処理効率が悪い<br>
1つの命令が完了してから次の命令に移るので処理に時間がかかる

### パイプライン方式

命令を1つずつステージをずらして処理を行う<br>
並行処理することでCPUの高速化が可能

```
命令取り出し → 命令解読     → オペランド読み出し・・・・
              命令取り出し → 命令解読・・・・
                            命令取り出し・・・・
```
「1つ目の命令解読」で使用しないリソースを使用して「2つ目の命令取り出し」を行っている

### 分岐予測と投機実行

命令によっては、前の命令の実行結果によって、取り出す命令が変わる可能性がある。<br>
その時は「分岐予測」で前の命令の実行結果を予測し、<br>
予測をもとに命令を実行「投機実行」している。

### パイプライン以上の高速化

<b>スーパーパイプライン</b>

命令実行手順を「細分化」することで、パイプライン処理の効率を上げる

<b>スーパースカラ</b>

パイプライン処理を複数持たせて同時に複数の命令を実行させる

### 設計思想(CISKとRISK)

- CISK : 1つの命令で複雑な処理を実行する (Complex Instruction Set Computer)
- RISK : 1つの命令で単純な処理を高速で実行する (Reduced Instruction Set Computer)

|  | CISK | RISK |
| :-- | :-: | --: |
| 設計思想 | CPUに「複雑な」命令体系を持たせる | CPUに「単純な」命令を持たせる |
| 特徴 | 1つの命令で複雑な命令の処理が可能になり、<br>「少ない行数の命令で処理を実行」する | 命令実行時間が均等になり、パイプライン方式で効率よく命令を処理することが可能。<br>また「1つ1つの命令が高速」となる |
| CPU性能 | 処理を少ない命令回数で完結させることでパフォーマンス向上を目指す | 1つ1つの処理を高速に実施することでトータルのパフォーマンス向上を目指す |

## 6.メモリの分類

ここから主記憶装置について学習する。こちらもよく出題される範囲。

### 主記憶装置の復習

- 主記憶装置 : データを一時的に保存
  - 容量が小さく・処理が早い
- 補助記憶装置 : データを長期的に保存
  - 容量が大きく・処理が遅い

### RAMとROM

- RAM(Random Access Memory)
  - 自由に読み書きが可能
  - 電源を切るとデータが消える 「揮発性」
- ROM(Read Only Memory)
  - 読み出し専用（データを書き込めない）
  - 電源を切ってもデータが消えない「不揮発性」

### いろいろなメモリの種類

- RAM
  - DRAM
  - SRAM
- ROM
  - マスクROM
  - PROM
    - EPROM
    - EEPROM

### RAMの分類(DRAMとSRAM)

|  | DRAM | SRAM |
| :-- | :-: | --: |
| ※ 回路 | コンデンサ(電気を蓄える) | フリップフロップ回路 |
| ※ リフレッシュ動作 | 必要(電荷の補充) | 不要 |
| 集積度(記憶容量) | 高い | 低い |
| ※ 価格 | 安価 | 高い |
| 速度 | 遅い | 速い |
| 主な用途 | 主記憶装置 | キャッシュメモリ |

<font color="magenta">
上記の※については良く出題される
</font>

### ROMの分類

| 種類 | 特徴 |
| :-- | --: |
| マスクROM | 読み出し専用メモリ。工場出荷時にデータを書き込み、その後はデータの書き込み不可 |
| EPROM(PROM) | 紫外線照射でデータを全消去して書き換える |
| EEPROM(PROM) | 電圧をかけてデータを部分消去して書き換える |
| フラッシュメモリ(PROM) | 「EEPROMの一種」で、「ブロック単位」でデータを書き換える |

## 7.メモリの高速化

### 主記憶装置の高速化が必要な理由

CPUの性能が良くても主記憶装置の読み書きが遅いと処理が遅くなる

主記憶装置の高速化の方法
1. キャッシュメモリの使用
2. メモリインタリーブ

### キャッシュメモリ

キャッシュメモリはCPU内部に組み込まれ、レジスタと主記憶装置間の速度差を埋める<br>
キャッシュメモリの中でも速度によって1次キャッシュ、2次キャッシュ・・・と分けて設置することが可能

<b>記憶装置の階層構造</b>

上にあるほど処理は速く、下に行くほど容量が大きい

- レジスタ
- キャッシュメモリ(速度差を埋める)
- 主記憶装置
- ディスクキャッシュ(速度差を埋める)
- 補助記憶装置

### キャッシュメモリの出題内容

データの読み込み・書き込みでそれぞれ出題される

- データの読み込み
  - 「実行アクセス時間」の計算問題が出題される
- データの書き出し
  - 「ライトバック方式」、「ライトスルー方式」での書き出し方法が出題される

### キャッシュメモリのデータ読み込み

主記憶装置からデータを読み込む際は、キャッシュメモリにも読み込まれる。<br>
データを再度使用する際は、キャッシュメモリからデータを取得できるので処理が高速<br>
キャッシュメモリは主記憶装置よりも容量が少ないため、全てのデータが存在するわけではない、<br>
キャッシュメモリにデータが無い場合は、主記憶装置からデータを取得する。

### ヒット率と実行アクセス時間

- キャッシュメモリにテータがある確率 : 「ヒット率」
- キャッシュメモリ/主記憶装置からデータを取得する時間の平均 : 「実行アクセス時間」

実行アクセス時間 = キャッシュメモリのアクセス時間 × ヒット率 + 主記憶装置のアクセス時間 × (1-ヒット率)

例）ヒット率が80％の場合
```
キャッシュメモリから「10秒」、主記憶装置から「30秒」かかるとしたら
10秒 × 80% + 30秒 × 20% = 14秒「実行アクセス時間」
```

### キャッシュメモリのデータ書き出し

- ライトスルー方式
  - キャッシュメモリと同時に主記憶装置へも書き込みを行う
    - 高速化 : ×
    - 信頼性と制御のしやすさ : 〇
- ライトバック方式
  - キャッシュメモリのみ書き込みを行い、キャッシュメモリのデータが一杯になったときに主記憶装置に書き戻しを行う
    - 高速化 : 〇
    - 信頼性と制御のしやすさ : ×

### メモリインタリーブ

キャッシュメモリを使用しない主記憶装置の高速化手法で、メモリを複数の区画に分割することで、一気にデータを取得することが可能になる。<br>
一般的な連続したデータを使用する命令に対して有効。

## 8.ハードディスクの構造と記憶容量

ここから補助記憶装置について学習する。

### HDDとSSD

- HDD(ハードディスクドライブ)
  - 安価
  - データ容量が大きい
  - 処理が遅い
  - 衝撃に弱い
- SSD(ソリッドステートドライブ)
  - データ容量に対して高価
  - 処理が速い
  - 衝撃に強い

### ハードディスクの構成

- 「プラッタ」
  - 磁性体を磁化させて情報を保存する
- 「アクセスアーム」
  - 目的地まで磁気ヘッドを運ぶ
- 「磁気ヘッド」
  - 磁界によってデータを記録したり読み取る

### プラッタの構造

- 「セクタ」
  - データを書き込む最小の単位
  - ピザで例えると1切れ
- 「トラック」
  - 同じ半径の位置にあるセクタの集まり
  - ピザの輪1周
- 「シリンダ」
  - 同じトラック位置を縦に結んだもの

### セクタへのデータの書き込み方

- 1つのセクタに収まらない場合は複数セクタ使用
- セクタで使われない領域は無駄になる

例）
```
1セクタ512バイトで700バイトのデータを書き込む場合

1つ目のセクタで512バイトを書き込み、2つ目のセクタでは残りの188バイトが書き込まれる。
そのとき残りの324バイトは他のデータを書き込むことが出来ず無駄になる。
```

### HDDの記憶容量

例）
```
セクタ : 512バイト
トラック : セクタ20個
シリンダ : トラック60個
プラッタ : シリンダ1500個

上記の場合、
512 × 20 × 60 × 1500 ≒ 922MB
```

## 9.ハードディスクの頻出分野

### 実行アクセス時間

- 「位置決め時間」(シーク時間)
  - 磁気ヘッドが読み書きしたいデータのトラックまで動く時間
- 「回転待ち時間」(サーチ時間)
  - プラッタを回転し、読み書きするセクタまで回転させる時間
- 「データ転送時間」
  - データを読み書きする時間

位置決め時間 + 回転待ち時間 = 「待ち時間」<br>
待ち時間 + データ転送時間 = 「アクセス時間」

<b>待ち時間の求め方</b>

最大時間と最小時間の平均を取って求める。<br>
よってプラッタが1/2回転する時間を待ち時間とする。

まとめ
```
アクセス時間 =
  位置決め時間 + 回転待ち時間 + データ転送時間

待ち時間 =
  位置決め時間 + 回転待ち時間

※ 回転待ち時間 : プラッタが1/2回転する時間
```

### データの管理

データの追加、更新、削除を行っていると、データのあるセクタがばらばらになる。<br>
この状態を「フラグメンテーション」と呼び、無駄な磁気ヘッドの移動が多くなり、アクセス時間増加の原因になる。

フラグメンテーションを解決するために、<br>
バラバラなデータを集めまとめる作業を「デフラグ」と呼ぶ。

### 性能向上（RAID）

RAID : 複数のハードディスクを組み合わせ、処理速度や信頼性を向上させる

<b>RAID0</b>

「ストライピング」 : 2台以上のハードディスクに分散してデータを書き込む
```
1番目HDD : データ1、データ2
2番目HDD : データ3、データ4
```
処理が高速化されるが、信頼性は低い。(HDDの故障に弱い)

<b>RAID1</b>

「ミラーリング」 : 2台以上のハードディスクに同じデータを書き込む
```
1番目HDD : データ1、データ2、データ3、データ4
2番目HDD : データ1、データ2、データ3、データ4
```
信頼性が向上

<b>RAID5</b>

3台以上のハードディスクに分散してデータとパリティを書き込む
```
1番目HDD : データ1
2番目HDD : データ2
3番目HDD : データ1，2のパリティ(データの復元が可能)
```
信頼性向上、高速化

## 10.その他補助記憶装置

出題頻度は少なめ

### 光ディスク

レーザー光線によってデータを読み書きする記憶媒体

