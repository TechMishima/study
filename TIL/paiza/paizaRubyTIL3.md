# ToDo
学習したことのアウトプット

# Til
### 小数点以下の扱い
四捨五入 round
```
100.3333.round # 出力結果 ==> 100
100.3333.round(1) # 出力結果 ==> 100.3
```
小数点以下切り上げ ceil
```
100.3333.ceil # 出力結果 ==> 101
100.3333.ceil(1) # 出力結果 ==> 100.4
```
小数点以下切り捨て floor
```
100.3333.floor # 出力結果 ==> 100
100.3333.floor(1) # 出力結果 ==> 100.3
```

## 配列が空で条件分岐する
```
if arr == []
  puts "配列は空です"
```
nilではないので注意！

## delete#at
指定された位置にある要素を取り除きそれを返す。
```
array = [0, 1, 2, 3, 4]
target = array.delete_at 2
puts target  # => 2
p array      # => [0, 1, 3, 4]
```

## insert
要素の挿入
```
ary = [1, 2, 3]
ary.insert(2, "a", "b")
p ary                  # => [1, 2, "a", "b", 3]
ary.insert(-2, "X")
p ary                  # => [1, 2, "a", "b", "X", 3]
```

## downto
https://uxmilk.jp/24052<br>
timesと似ている
```
5.downto(1) {|i| print i, " " } # => 5 4 3 2 1
```
```
obj.downto(min){|int|
 "繰り返し実行する処理"
}
#又は
obj.downto(min) do |int|
 "繰り返し実行する処理"
end
```
## upto
```
obj.upto(max){|int|
  "繰り返し実行する処理"
}
#又は
obj.upto(max) do |int|
 "繰り返し実行する処理"
end
```

## ハッシュに配列を入れたい！
ハッシュに配列を作成しようとしても同一オブジェクトの配列を作成してしまう。なぜなのか
>Hash.new(0): これは各キーに対して独立したスカラー値 0 を提供するため、+= 1 のような操作が意図したとおりに動作します。<br>
Hash.new([]): これはキーが存在しない場合に同一の配列を返すため、意図しない共有が発生します。この共有が原因で、思わぬ挙動が見られることがあります。

>hash = Hash.new { |h, k| h[k] = [] }を使用することで解決ができる

```
hash1 = Hash.new(0)
hash1[1] += 1
hash1[1] += 1
p hash1[1]  # => 2
p hash1[2]  # => 0


hash2 = Hash.new([])
hash2[1] << 1
hash2[1] << 2
p hash2[1]  # => [1, 2]
p hash2[2]  # => [1, 2]


hash3 = Hash.new { |h, k| h[k] = [] }
hash3[1] << 1
hash3[1] << 2
p hash3[1] # => [1, 2]
p hash3[2] # => []
```

## ハッシュのeachメソッドでは取り出した値が変わる？

下記は配列として出力され、:aの値,1の値になる。<br>
キーを取り出すときはa[0]、値を取り出すときはa[1]となる。<br>
```
{:a=>1, :b=>2}.each {|a| p a}
#=> [:a, 1]
#   [:b, 2]
```

下記はキーとシンボルとして取り出すことができる。<br>
値を取り出すときはv、キーを取り出すときはkになる。<br>
こっちの方が扱いやすそう。
```
{:a=>1, :b=>2}.each {|k, v| p [k, v]}
#=> [:a, 1]
#   [:b, 2]
```
