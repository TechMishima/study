# ToDO
情報処理入門 テクノロジー編<br>
https://paiza.jp/works/technology/primer

# TIL1 コンピュータのデータ表現

## 1-1 コンピュータのデータ表現について学んでいこう

学習内容の確認

- 表現単位
- 基数
- 数値の表現
- 誤差
- シフト演算

## 1-2 基本的なデータの単位と接頭辞

### 表現単位

| 0                  | 1                  |
|---------------------|---------------------|
| 電気が流れていない | 電気が流れている   |
| 電圧が低い          | 電圧が高い          |

最小単位の0，1の事をビットという。<br>
8ビット=1バイト

### 表現の種類

1ビットだと1、0の2種類<br>
2ビットだと00，01，10，11の4種類<br>
すなわち、nビットだと2のn乗種類の表現ができる。
$$ nビット ・・ 2^n種類 $$

### 接頭辞

言葉のはじめにつけて意味を加える言葉、ITでは数値を見やすくするための手法。<br>
1000g = 1kg<br>
上記のkのキロが接頭辞にあたる。<br>

### 大きな値を表すときに使われる接頭辞

| 記号 | 読み方 | 10進数 | 2進数    |
|------|--------|--------|----------|
| K    | キロ   | 10³    | 2¹⁰      |
| M    | メガ   | 10⁶    | 2²⁰      |
| G    | ギガ   | 10⁹    | 2³⁰      |
| T    | テラ   | 10¹²   | 2⁴⁰      |
| P    | ペタ   | 10¹⁵   | 2⁵⁰      |

### 小さな値を表すときに使われる接頭辞

| 記号 | 読み方     | 10進数   | 2進数    |
|------|------------|----------|----------|
| m    | ミリ       | 10⁻³     | 2⁻¹⁰     |
| μ    | マイクロ   | 10⁻⁶     | 2⁻²⁰     |
| n    | ナノ       | 10⁻⁹     | 2⁻³⁰     |
| p    | ピコ       | 10⁻¹²    | 2⁻⁴⁰     |

### 正確に区別する場合

| 記号 | 読み方     | 2進数    |
|------|------------|----------|
| Ki   | キビ       | 2¹⁰      |
| Mi   | メビ       | 2²⁰      |
| Gi   | ギビ       | 2³⁰      |
| Ti   | テビ       | 2⁴⁰      |
| Pi   | ペビ       | 2⁵⁰      |

## 1-3 基数

基数とは数値を表現するときに、位取りのもととなる値のこと。<br>

$$ 267.8 = 2*10^2 + 6* 10^1 + 7*10^0 +8*10^-1 $$

上記の10を基数と呼び、上の数字をべき乗と呼ぶ。<br>
10進数を表記するときは（110.1）₁₀のように右下に表記する。<br>
８進数や16進数もある。<br>
なぜ8と16なのかは、2進数から変換するときに行いやすいから。

## 1-4 基数変換

基数を扱いやすいように変換する。

2進数から8進数、16進数は変換しやすい。<br>
しかし2進数から10進数へは規則性がないため、計算しなくてはいけない。

### 2進数から10進数への基数変換

例 1011(2進数)の変換

1, 右から左へ、各桁に 2 の累乗（べき乗）をかける

1 × 2^3 = 8  
0 × 2^2 = 0  
1 × 2^1 = 2  
1 × 2^0 = 1

2, すべて足し算する

8 + 0 + 2 + 1 = 11（10進数）

### 10進数から2進数への基数変換

例 10.625（10進数）を2進数に変換

1, 整数部分の変換

10 ÷ 2 = 5 余り 0  
5 ÷ 2 = 2 余り 1  
2 ÷ 2 = 1 余り 0  
1 ÷ 2 = 0 余り 1  

→ 下から読む → 1010

2, 小数部分の変換

0.625 × 2 = 1.25     → 整数部分「1」、残り「0.25」
0.25 × 2  = 0.5      → 整数部分「0」、残り「0.5」
0.5 × 2   = 1.0      → 整数部分「1」、残り「0.0」→終了

→ 上から読む → 101

3, 合計して1010.101になる。

## 1-5 数値表現 - その1

- 2進数
  - コンピュータ内部で計算を行うときに適している。

- 10進数
  - 人間にとって馴染みがあり、わかりやすい

### 2進化10進コード（BCDコード）

10進数で表された、数字を各桁で区切って2進数に変換したコード

例 10進数 1649

1 ・・・ 0001<br>
6 ・・・ 0110<br>
4 ・・・ 0100<br>
9 ・・・ 1001

2進化10進コード 0001 0110 0100 1001

### ゾーン10進数

ゾーンビット,2進化10進コード,符号ビット,2進化10進コードの順番になる。

EBCDICだと、<br>
ゾーンビット : 1111<br>
符号ビット : (+)1100 (-)1101<br>
になる。

例） 10進数 -1763

1763を2進化10進コードにする。<br>
0001 0111 0110 0011

ゾーンビットを配置していき、最後だけ符号ビットを配置する。<br>
1111 (0001) 1111 (0111) 1111 (0110) 1101 (0011)<br>
1111 0001 1111 0111 1111 0110 1101 0011

### パック10進数

(0000),2進化10進コード,符号ビットの順番になる。<br>
0000は偶数桁の場合、つける。

例 ）
+528

5.2.8.+の順番に配置する。<br>
0101 0010 1000 1100

-1763

偶数桁なので0000を先頭につける。<br>
0000.1.7.6.3.-の順番に配置する。<br>
0000 0001 0111 0110 0011 1101

### ゾーン10進数とパック10進数の関係

- ゾーン10進数<br>
入力装置から10進数で入力する場合や出力装置で10進数を出力する場合はゾーン10進数を使ったほうが簡単

- パック10進数<br>
より少ないバイト数で多くの情報を表現することができる

ゾーン10進数からパック10進数へ変換することを「パック」といい、<br>
逆にパック10進数からゾーン10進数へ変換することを「アンパック」という。

## 1-6 数値表現 - その2

### コンピュータ上で小数を表現する方法

- 固定小数点数
  - 整数部と小数部の桁数をあたかじめ決めておく
- 浮動小数点数
  - 表現する値に合わせて小数点の位置を変える

### 固定小数点数

最上位ビット<br>
正 : 0  負 : 1

固定小数点数で負の数を表すときは、補数を用いる。

### 補数とは？

ある数に足したとき、桁が1つ上がる最も小さい数

例）<br>
98 + 1 = 99 ・・・桁は上がっていない<br>
98 + 2 = 100 ・・・桁は上がっている<br>
98 + 3 = 101 ・・・桁は上がっている<br>
上記より、桁が上がる最も小さい数は「2」となる。

### 負の数を2進数で表す方法

補数を用いる。<br>
ある数(負の数)に正の数を足したとき、桁が1つあがり、0になる数を計算する。<br>

例）-25を2進数にする

1. 正の数25を2進数にする。<br>
(25)₁₀ ⇒ (00011001)₂<br>
2. 0に正の数25を引く。<br>
(100000000)₂ - (00011001)₂ = (11100111)₂

簡単な方法）
1. 正の数25を2進数にする。<br>
(25)₁₀ ⇒ (00011001)₂<br>
2. 0と1をひっくり返す。<br>
00011001 ⇒ 11100110
3. 一番下を1プラスする。<br>
11100110 ⇒ 11100111

### 補数表現が用いられている理由

減算を加算に置き換えて演算できるから

例） 15-10<br>
2進数へ変換する。<br>
15 = (00001111)₂<br>
10 = (00001010)₂

0から10を引く。<br>
-10 = (11110110)₂

15と-10を足してみて、5にあたるか確認する。<br>
(00001111)₂ + (11110110)₂ = (00000101)₂ = 5

## 1-7 数値表現 - その3

固定小数点数だと、大きな数値やとても小さい小数点以下の数値を扱うとき、大量のビットが必要になってしまう。<br>
浮動小数点数にすることで扱いが容易になる。

例）120000000<br>
= 0.12 * 10⁹<br>
= (-1)⁰ * 0.12 * 10⁹

上記より
- 符号 ・・・ 0
  - 数値が正か負を表現する
- 仮数 ・・・ 12
  - 小数点以下に変換された数値
- 指数 ・・・ 9
  - 仮数に10の何乗をかけるか

(-1)符号 * 仮数 * (基数)指数

### IEEE754形式 (ｱｲﾄﾘﾌﾟﾙｲｰ754)

- 単精度浮動小数点数(32ビット形式)
  - 符号部 1ビット
  - 指数部 8ビット
  - 仮数部 23ビット
- 倍精度浮動小数点数(64ビット形式)
  - 符号部 1ビット
  - 指数部 11ビット
  - 仮数部 52ビット

### 各部の説明
- 符号部 : 数値の符号を表す(正=0, 負=1)
- 指数部 : 基数に対する指数を表す
  - 2の補数 : 指数を2進数で記録
  - エクセス方式 : 指数に一定の値を加算した値を記録
    - エクセス127 : 一定の値127を足す
    - エクセス64 : 一定の値64を足す
-  仮数部 : 小数点以下の数値を表す (先頭を1にするか0にするか 基本は1)

### 正規化

仮数部に使用できる数字を増やし、数値の制度を保つ

例） 0.000123456789

そのままの状態で仮数部に記録すると・・・<br>
0 0 0 1 2 3 4

0.123456789 * 10^-3に変換してから記録すると<br>
1 2 3 4 5 6 7

### 例題

(1234.625)₁₀<br>
IEEE754形式の単精度浮動小数点数(32ビット)で表現
- 符号部 : 正なので0
- 指数部 : 基数を2とするエクセス127方式
- 仮数部 : 整数部を1とする

1. 1234.625を2進数へ変換し、正規化する

(1234.625)₁₀ = (10011010010.101)₂<br>
正規化 : (1.0011010010101)₂ * 2*10

2. 指数をエクセス127方式の2進数に変換

10 + 127 = (137)₁₀ = (10001001)₂

3. 表示形式に合わせて記述

- 符号部(1ビット) : 0
- 指数部(8ビット) : 10001001
- 仮数部(23ビット) : 00110100101010000000000

合わせて<br>
01000100100110100101010000000000

## 1-8 誤差

### 誤差とはなにか

真値とコンピュータ内部で表現できる値との差のこと。

### 誤差の種類

- 丸め誤差
- 打ち切り誤差
- 情報落ち
- 桁落ち
- オーバーフロー
- アンダーフロー

### オーバーフロー

計算結果がその値の範囲を超えること<br>
適切な範囲設定をすることによって、回避可能。

例） 32ビット整数

32桁で表現できる数値より大きな数値はオーバーフローがおきる。<br>
符号なしの場合は2の32乗が表現できる数値になるので<br>
2³² = 4294967296<br>
上記の数値より大きい値については、オーバーフローになる。

<b>負のオーバーフロー</b>

表現できる数が符号なしのとき、0を下回る数値は表現できない。<br>
0を下回り誤差が起きることを、負のオーバーフローという。

### アンダーフロー

値が小さくなり過ぎて表現できなくなってしまうこと<br>
適切な範囲設定をすることによって、回避可能。

浮動小数点数でおこる。

例） 1.5を2で割り続ける

1.5 = 0 01111111 100.......<br>
2で割ると<br>
0.7 = 0 01111110 100.......

2で割る回数が127回目のとき、<br>
0 00000000 11000......<br>
上記になり、指数部は全部0になり、仮数部に変化がでる。

2で割る回数が150回目のとき、<br>
0 0000000 000....001<br>
上記をさらに2で割り、151回目に達したとき、<br>
0 0000000 000....000<br>
仮数部も完全に0になってしまい、表現できなくなってしまう。

### 丸め誤差

途中の桁で、切捨や切上や四捨五入をおこなうことによって生じる誤差のこと<br>
コンピュータで数値を表現するときに、限られた桁数に収めるために生じる

例） 1/10 → 0.100000000149011.....となる

32ビットの浮動小数点にする<br>
0 01111011 1001.......101<br>
1001で循環しているが、最後だけ101になってしまう<br>
よって、丸め誤差が生まれてしまっている。

有効数字を適切に設定することで対応できる。

### 桁落ち

数値計算において引き算した結果が非常に小さいとき、有効数字が減少することによって生じる

例）8.13813-8.13811=0.00002

10進数なら0.00002になるが、2進数で引き算したときには<br>
0 10000010 000......10101になる。<br>
ここで正規化したときに仮数部の後ろが0で埋まる。<br>
0 01101111 01010000000........<br>
後ろの0で埋まった部分が誤差となっている。

### 情報落ち

絶対値の非常な大きな値と非常に小さな値の演算をするときに、<br>
小さな値の方が無視されてしまうことで生じる

例）1000 + 0.0001 = 1000<br>
0.0001が非常に小さいため、反映されない

<b>対策</b>
- 小さな値同士から計算を処理する
- 有効桁数の大きい64ﾋﾞｯﾄ浮動小数を使う

### 打切り誤差

無限小数で表現される数値などを有限項の計算で打ち切ることによる誤差

例）ルート3や円周率など

## 1-9 シフト演算

10進数でシフト演算をする。

1を左にずらし、空いたところを0で埋めると10になる。<br>
10に再び行うと100になる。<br>
左にずらすたびに10倍されていく。

逆に右にずらすと1/10されていく。


### 論理シフト

1. シフトした結果、はみ出した値は切り捨てる。
2. シフトした結果、空いたビット位置には0を挿入する。

例） (34)₁₀ = (00100010)₂を左に2ビット論理シフトする

左に論理シフトすると(01000100)₂になる。<br>
10進数にすると68になっている。<br>
つまり、左に2ビット論理シフトすると2倍される。<br>
逆に右に2ビット論理シフトすると1/2倍される。

ルール1により、はみ出した値が1だった時、切り捨ててしまい誤差につながる。

### 算術シフト

負の値をシフト演算することができる。

1. 符号ビットはシフトしない
2. シフトした結果、はみ出したビットは切り捨てる。
3. シフトした結果、空いたビット位置には左シフトの場合は0を挿入し、<br>
  右シフトの場合は符号ビットと同じものを挿入する。

例） (-30)₁₀ = (11100010)₂を右に2ビット算術シフトする

1. 符号ビットはシフトしない

1 1100010

2. シフトした結果、はみ出したビットは切り捨てる。

1 ()110001<br>
0は切り捨てる

3. 空いたビット位置に符号ビットと同じものを挿入する

1 (1)110001

よって 11110001になる。<br>
値は-15

### 2ビットシフト演算について

- 左にnビットシフトすると、もとの数の2のn乗倍になる